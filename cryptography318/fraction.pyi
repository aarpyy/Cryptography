from typing import Type, TypeVar, Union, overload, Any, Optional
from numbers import Real, Rational, Integral, Complex

_T = TypeVar("_T")


class SquareRoot(Real):

    @overload
    def __new__(cls: Type[_T], operand: Union[int, float, Rational], coefficient:
    Optional[Union[int, float, Rational]] = ..., _normalize: bool = ...) -> Union[_T, int, float]: ...

    @overload
    def __new__(cls: Type[_T], operand: str, _normalize: bool = ...) -> Union[_T, int, float]: ...

    @property
    def eval(self: _T) -> float: ...

    @property
    def radicand(self: _T) -> int: ...

    @property
    def coefficient(self: _T) -> int: ...

    # for the forward operators, there is no method to deal with input type Any because NotImplemented is
    # returned if other is not SquareRoot, int, float, or complex

    # __add__, __radd__
    @overload
    def __add__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __add__(self: _T, other: Union[int, float]) -> float: ...
    @overload
    def __add__(self: _T, other: complex) -> complex: ...
    @overload
    def __radd__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __radd__(self: _T, other: Real) -> float: ...
    @overload
    def __radd__(self: _T, other: Complex) -> complex: ...
    @overload
    def __radd__(self: _T, other: Any) -> Any: ...

    # __sub__, __rsub__
    @overload
    def __sub__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __sub__(self: _T, other: Union[int, float]) -> float: ...
    @overload
    def __sub__(self: _T, other: complex) -> complex: ...
    @overload
    def __rsub__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __rsub__(self: _T, other: Real) -> float: ...
    @overload
    def __rsub__(self: _T, other: Complex) -> complex: ...
    @overload
    def __rsub__(self: _T, other: Any) -> Any: ...

    # __mul__, __rmul__
    @overload
    def __mul__(self: _T, other: SquareRoot) -> Union[SquareRoot, int]: ...
    @overload
    def __mul__(self: _T, other: Union[int, float]) -> float: ...
    @overload
    def __mul__(self: _T, other: complex) -> complex: ...
    @overload
    def __rmul__(self: _T, other: SquareRoot) -> Union[SquareRoot, int]: ...
    @overload
    def __rmul__(self: _T, other: Real) -> float: ...
    @overload
    def __rmul__(self: _T, other: Complex) -> complex: ...
    @overload
    def __rmul__(self: _T, other: Any) -> Any: ...

    # __floordiv__, __rfloordiv__
    @overload
    def __floordiv__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __floordiv__(self: _T, other: Union[int, float]) -> float: ...
    @overload
    def __floordiv__(self: _T, other: complex) -> complex: ...
    @overload
    def __rfloordiv__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __rfloordiv__(self: _T, other: Real) -> float: ...
    @overload
    def __rfloordiv__(self: _T, other: Complex) -> complex: ...
    @overload
    def __rfloordiv__(self: _T, other: Any) -> Any: ...

    # __truediv__, __rtruediv__
    @overload
    def __truediv__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __truediv__(self: _T, other: Union[int, float]) -> float: ...
    @overload
    def __truediv__(self: _T, other: complex) -> complex: ...
    @overload
    def __rtruediv__(self: _T, other: SquareRoot) -> Union[SquareRoot, float]: ...
    @overload
    def __rtruediv__(self: _T, other: Real) -> float: ...
    @overload
    def __rtruediv__(self: _T, other: Complex) -> complex: ...

    @overload
    def __mod__(self: _T, other: int) -> Union[SquareRoot, float]: ...
    @overload
    def __mod__(self: _T, other: Any) -> Any: ...

    def __rmod__(self: _T, other: Any) -> Any: ...

    def __pow__(self: _T, exponent: Union[int, float]) -> Union[int, float]: ...

    def __rpow__(self: _T, base: Any) -> Any: ...

    def __float__(self: _T) -> float: ...

    def __int__(self: _T) -> int: ...

    def __complex__(self: _T) -> complex: ...

    def __trunc__(self: _T) -> int: ...

    def __floor__(self: _T) -> int: ...

    def __ceil__(self: _T) -> int: ...

    def __abs__(self: _T) -> SquareRoot:

    def __neg__(self: _T) -> SquareRoot: ...

    def __pos__(self: _T) -> SquareRoot: ...

    def __hash__(self: _T) -> int: ...

    @overload
    def __round__(self: _T, ndigits: None = ...) -> Integral: ...
    @overload
    def __round__(self: _T, ndigits: int = ...) -> Real: ...

    def __str__(self: _T) -> str: ...

    def __repr__(self: _T) -> str: ...

    def __eq__(self: _T, other: Any) -> bool: ...

    def __ne__(self: _T, other: Any) -> bool: ...

    def __lt__(self: _T, other: Any) -> bool: ...

    def __le__(self: _T, other: Any) -> bool: ...

    def __gt__(self: _T, other: Any) -> bool: ...

    def __ge__(self: _T, other: Any) -> bool: ...
