from itertools import islice
from typing import Generator, Optional, Sequence, overload


def get_details() -> str: ...

class Sieve:
    data: list[int]

    def __init__(self) -> None: ...

    @overload
    def __getitem__(self, item: int) -> int: ...

    @overload
    def __getitem__(self, item: slice) -> list[int]: ...

    def __getitem__(self, item: int | slice) -> int | list[int]: ...

    def __contains__(self, item: int) -> bool: ...

    def __len__(self) -> int: ...

    def __iter__(self) -> Generator: ...

    @overload
    def search(self, value: int) -> int | tuple[int, int]: ...

    @overload
    def search(self, value: int, *args: int) -> tuple[int | tuple[int, int]]: ...

    def extend(self, n: int) -> None: ...

    def load(self, file: str = ..., overwrite: bool = ...) -> None: ...

    def range(self, a: int, b: Optional[int] = ...) -> Optional[islice]: ...

    @property
    def list(self) -> list[int]: ...

    @property
    def tail(self) -> int: ...


primesieve: Sieve


def miller_rabin(n: int, k: int = ..., *, details: bool = ...) -> bool: ...


def miller_rabin_bases(bases: list[int], n: int, *, details: bool = ...) -> bool: ...


def baillie_psw(n: int, mr: bool = ...) -> bool: ...


def known_prime(n: int) -> bool: ...


def isprime(n: int, *, details: bool = ...) -> bool: ...


def randprime(a: int, b: int = ...) -> int: ...


def confirm_prime(n: int) -> bool: ...


def next_prime(n: int) -> int: ...


def prev_prime(n: int) -> int: ...


def prime_range(a: int, b: Optional[int] = ...) -> list[int]: ...


def sqrt_mod(a: int, p: int) -> Optional[int]: ...


def lift_sqrt(root: int, n: int, modulus: int, q: int = ...) -> int: ...


def quadratic_residue(a: int, p: int) -> bool: ...


def quadratic_non_residue(a: int, p: int) -> bool: ...


def chinese_remainder(values: Sequence[int], moduli: Sequence[int]) -> int: ...
