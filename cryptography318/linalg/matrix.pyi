from collections import UserList
from typing import Optional, Iterable, Iterator, overload
from numbers import Real
from .vector import Vector


class Matrix(UserList[Vector]):
    data: list[Vector]
    _m: int
    _n: Optional[int]
    def __init__(self: Matrix, initlist: Optional[Iterable[Iterable[Real]]] = ...) -> None: ...
    @property
    def transpose(self: Matrix) -> Matrix: ...
    @property
    def shape(self: Matrix) -> tuple[int, ...]: ...
    def __add__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __radd__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __iadd__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __sub__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __rsub__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __isub__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __mul__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __rmul__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __imul__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __truediv__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __floordiv__(self: Matrix, other: Iterable[Iterable[Real] | Real] | Real) -> Matrix: ...
    def __mod__(self: Matrix, other: Real) -> Matrix: ...
    def __matmul__(self: Matrix, other: Iterable[Iterable[Real] | Real]) -> Matrix: ...
    def __rmatmul__(self: Matrix, other: Iterable[Iterable[Real] | Real]) -> Matrix: ...
    @overload
    def __setitem__(self: Matrix, key: int, value: Iterable[Real]) -> None: ...
    @overload
    def __setitem__(self: Matrix, key: slice, value: Iterable[Iterable[Real]]) -> None: ...
    def append(self: Matrix, item: Iterable[Real]) -> None: ...
    def extend(self: Matrix, other: Iterable[Iterable[Real]]) -> None: ...
    def insert(self: Matrix, i: int, item: Iterable[Real]) -> None: ...

    # All of these methods are not overloaded from superclass but their return types are better known
    @overload
    def __getitem__(self: Matrix, item: int) -> Vector: ...
    @overload
    def __getitem(self: Matrix, item: slice) -> Matrix: ...
    def pop(self: Matrix, i: int = ...) -> Vector: ...
    def __iter__(self: Matrix) -> Iterator[Vector]: ...
    def __reversed__(self: Matrix) -> Iterator[Vector]: ...
