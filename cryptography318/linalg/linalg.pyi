from typing import Any, Iterable, Sequence, Optional, Union, TypeVar, MutableSequence
from sympy import Symbol, Expr

T = TypeVar("T")

def strmat(a: Sequence[Sequence[Any]]) -> str: ...
def dot(a: Sequence, b: Sequence) -> int: ...
def transpose(a: Sequence[Sequence[T]]) -> list[list[T]]: ...
def matmul(a: Sequence[Sequence[T]], b: Sequence[Sequence[Any]]) -> list[list[T]]: ...
def flatten(a: Iterable[Union[T, Iterable[T]]]) -> list[T]: ...
def matrix_slice(a: Sequence[Sequence[T]], index: int) -> tuple[list[Sequence[T]], list[Sequence[T]]]: ...
def matrix_copy(a: Sequence[Sequence[T]]) -> list[Sequence[T]]: ...
def matrix_equals(a: Sequence[Sequence[Any]], b: Sequence[Sequence[Any]]) -> bool: ...
def make_pivot(a: Sequence[T], index: Optional[int] = ...) -> list[T]: ...
def row_reduce(a: MutableSequence[Sequence[Any]], row: int, col: int) -> None: ...
def identity_matrix(size: int) -> list[list[int]]: ...
def rref(a: Sequence[Sequence[T]], offset: int = ...) -> list[Sequence[T]]: ...
def kernel(a: Iterable[Iterable[T]]) -> list[list[T]]: ...
def binary_kernel(a: Iterable[Iterable[int]]) -> list[list[int]]: ...
def det(a: Iterable[Any]) -> float: ...
def minor(a: Sequence[Sequence[T]], index: Optional[int] = ...) -> T: ...
def char_poly(a: Sequence[Sequence[Any]], sym: Union[str, Symbol] = ...) -> Expr: ...
def eigvals(a: Sequence[Sequence[Any]]) -> list[Union[float, complex]]: ...
def eigvec(
        a: Sequence[Sequence[T]],
        values: Optional[Iterable[Union[float, complex]]] = ...
) -> dict[Union[float, complex], Union[list[list[T]], list[T]]]: ...
