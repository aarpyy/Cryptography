from typing import Any, Iterable, Sequence, Optional, Union, TypeVar, MutableSequence
from sympy import Symbol, Expr
from matrix import Matrix

_T = TypeVar("_T")

# Matrix methods
def print_matrix(m: Matrix, ret: bool = ..., rnd: int = ...) -> Optional[str]: ...

# Standard linalg procedures
def dot(a: Sequence, b: Sequence) -> int: ...
def transpose(a: Sequence[Sequence[_T]]) -> list[list[_T]]: ...
def matmul(a: Sequence[Sequence[_T]], b: Sequence[Sequence[Any]]) -> list[list[_T]]: ...
def flatten(a: Iterable[Union[_T, Iterable[_T]]]) -> list[_T]: ...
def matrix_slice(a: Sequence[Sequence[_T]], index: int) -> tuple[list[Sequence[_T]], list[Sequence[_T]]]: ...
def matrix_copy(a: Sequence[Sequence[_T]]) -> list[Sequence[_T]]: ...
def matrix_equals(a: Sequence[Sequence[Any]], b: Sequence[Sequence[Any]]) -> bool: ...
def make_pivot(a: Sequence[_T], index: Optional[int] = ...) -> list[_T]: ...
def row_reduce(a: MutableSequence[Sequence[Any]], row: int, col: int) -> None: ...
def identity_matrix(size: int) -> list[list[int]]: ...
def rref(a: Sequence[Sequence[_T]], offset: int = ...) -> list[Sequence[_T]]: ...
def kernel(a: Iterable[Iterable[_T]]) -> list[list[_T]]: ...
def binary_kernel(a: Iterable[Iterable[int]]) -> list[list[int]]: ...
def is_square(a: Sequence) -> bool: ...
def det(a: Sequence) -> float: ...
def minor(a: Sequence[Sequence[_T]], index: Optional[int] = ...) -> _T: ...
def char_poly(a: Sequence[Sequence[Any]], sym: Union[str, Symbol] = ...) -> Expr: ...
def eigvals(a: Sequence[Sequence[Any]]) -> list[Union[float, complex]]: ...
def eigvec(
        a: Sequence[Sequence[_T]],
        values: Optional[Iterable[Union[float, complex]]] = ...
) -> dict[Union[float, complex], Union[list[list[_T]], list[_T]]]: ...
