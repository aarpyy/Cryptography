from typing import Any, Iterable, Sequence, Optional, Union, TypeVar, MutableSequence
from collections.abc import Callable
from numbers import Real
from sympy import Symbol, Expr

T = TypeVar("T")
E = TypeVar("E", Real, Expr)

def dot(a: Sequence, b: Sequence) -> int: ...
def transpose(a: Sequence[Sequence[T]]) -> list[list[T]]: ...
def matmul(a: Sequence[Sequence[T]], b: Sequence[Sequence[Any]]) -> list[list[T]]: ...
def flatten(a: Iterable[Union[T, Iterable[T]]]) -> list[T]: ...
def matrix_slice(a: Sequence[Sequence[T]], index: int) -> MutableSequence[MutableSequence[T]]: ...
def matrix_copy(a: Sequence[MutableSequence[T]]) -> list[MutableSequence[T]]: ...
def matrix_equals(a: Sequence[Sequence[Any]], b: Sequence[Sequence[Any]]) -> bool: ...
def make_pivot(a: Sequence[T], index: Optional[int] = ...) -> list[T]: ...
def row_reduce(a: MutableSequence[MutableSequence[T]], row: int, col: int) -> None: ...
def identity_matrix(size: int) -> list[list[int]]: ...
def rref(a: MutableSequence[MutableSequence[T]], offset: int = ...) -> MutableSequence[MutableSequence[T]]: ...
def kernel(a: MutableSequence[MutableSequence[T]]) -> list[MutableSequence[T]]: ...
def binary_kernel(a: MutableSequence[MutableSequence[int]]) -> list[MutableSequence[int]]: ...
def det(a: Iterable[Any]) -> float: ...
def minor(a: MutableSequence[Sequence[E]], index: Optional[int] = ...) -> E: ...
def char_poly(a: MutableSequence[Sequence[E]], sym: Union[str, Symbol] = ...) -> list[E]: ...
def eigvals(a: MutableSequence[Sequence[E]]) -> list[Union[float, complex]]: ...
def eigvec(
        a: MutableSequence[Sequence[T]],
        values: Optional[Iterable[Union[float, complex]]] = ...
) -> dict[Union[float, complex], list[MutableSequence[T]]]: ...
