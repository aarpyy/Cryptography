from collections import UserList
from typing import Iterable, Optional, TypeVar
from numbers import Real

# Type for class of self, not always Vector in case this is subclassed
_S = TypeVar("_S")

class Vector(UserList):
    def __init__(self: _S, initlist: Optional[Iterable[Real]] = ...) -> None: ...
    def __add__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __radd__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __iadd__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __sub__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __rsub__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __isub__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __mul__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __rmul__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __imul__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __truediv__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __floordiv__(self: _S, other: Iterable[Real] | Real) -> _S: ...
    def __mod__(self: _S, other: Real) -> _S: ...
    def __matmul__(self: _S, other: Iterable[Real] | Real) -> Real: ...
    def __setitem__(self: _S, key: int, value: Real) -> None: ...
    def append(self: _S, item: Real) -> None: ...
    def extend(self: _S, other: Iterable[Real]) -> None: ...
    def insert(self: _S, i: int, item: Real) -> None: ...
