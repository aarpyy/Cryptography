from typing import Union, overload, Any, Optional, Literal
from numbers import Real, Rational, Complex
from fractions import Fraction as PyFraction
from abc import ABCMeta, abstractmethod


class Sqrt(Real):

    @overload
    def __new__(cls,
                operand: Union[int, float, Rational, Sqrt] = ...,
                *,
                _normalize: bool = ...
                ) -> Union[Sqrt, int, Mul]: ...

    @overload
    def __new__(cls,
                operand: str = ...,
                *,
                _normalize: bool = ...
                ) -> Union[Sqrt, int, Mul]: ...

    @property
    def eval(self) -> float: ...

    @property
    def radicand(self) -> int: ...

    @property
    def numerator(self) -> Sqrt: ...

    @property
    def denominator(self) -> Literal[1]: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    # for the forward operators, there is no method to deal with input type Any because NotImplemented is
    # returned if other is not SquareRoot, int, float, or complex

    # __add__, __radd__
    @overload
    def __add__(self, other: Sqrt) -> Union[Mul, Add]: ...
    @overload
    def __add__(self, other: int) -> Add: ...
    @overload
    def __add__(self, other: float) -> float: ...
    @overload
    def __add__(self, other: complex) -> complex: ...
    @overload
    def __radd__(self, other: Sqrt) -> Union[Mul, Add]: ...
    @overload
    def __radd__(self, other: int) -> Add: ...
    @overload
    def __radd__(self, other: float) -> float: ...
    @overload
    def __radd__(self, other: Real) -> Add: ...
    @overload
    def __radd__(self, other: Complex) -> complex: ...

    # __mul__, __rmul__
    @overload
    def __mul__(self, other: int) -> Union[Sqrt, Mul]: ...
    @overload
    def __mul__(self, other: Sqrt) -> Union[Sqrt, int]: ...
    @overload
    def __mul__(self, other: float) -> float: ...
    @overload
    def __mul__(self, other: complex) -> complex: ...
    @overload
    def __rmul__(self, other: int) -> Union[Sqrt, Mul]: ...
    @overload
    def __rmul__(self, other: Sqrt) -> Union[Sqrt, int]: ...
    @overload
    def __rmul__(self, other: float) -> float: ...
    @overload
    def __rmul__(self, other: Real) -> Mul: ...
    @overload
    def __rmul__(self, other: Complex) -> complex: ...

    # __floordiv__, __rfloordiv__
    @overload
    def __floordiv__(self, other: Sqrt) -> Union[Literal[1], float]: ...
    @overload
    def __floordiv__(self, other: Union[Literal[1], Literal[-1]]) -> Sqrt: ...
    @overload
    def __floordiv__(self, other: Any) -> Any: ...
    @overload
    def __rfloordiv__(self, other: int) -> Union[Sqrt, float]: ...
    @overload
    def __rfloordiv__(self, other: Any) -> Any: ...

    # __truediv__, __rtruediv__
    @overload
    def __truediv__(self, other: Sqrt) -> Union[Literal[1], float]: ...
    @overload
    def __truediv__(self, other: Union[Literal[1], Literal[-1]]) -> Sqrt: ...
    @overload
    def __truediv__(self, other: Any) -> Any: ...
    @overload
    def __rtruediv__(self, other: int) -> Union[Sqrt, float]: ...
    @overload
    def __rtruediv__(self, other: Any) -> Any: ...

    @overload
    def __mod__(self, other: Sqrt) -> Union[Literal[0], float]: ...
    @overload
    def __mod__(self, other: Any) -> Any: ...
    def __rmod__(self, other: Any) -> Any: ...
    def __pow__(self, exponent: int) -> Union[int, Mul, float]: ...
    def __rpow__(self, base: Any) -> Any: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __abs__(self) -> Sqrt: ...
    def __neg__(self) -> Sqrt: ...
    def __pos__(self) -> Sqrt: ...
    def __hash__(self) -> int: ...
    def __round__(self, ndigits: Optional[int] = ...) -> Real: ...
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...


class Expr(metaclass=ABCMeta):

    @abstractmethod
    def __init__(self): ...

    @property
    @abstractmethod
    def eval(self) -> Union[int, float]: ...

    @abstractmethod
    def simplify(self, *, _update: Optional[bool] = ...) -> Expr: ...

    @abstractmethod
    def __str__(self): ...

    @abstractmethod
    def __repr__(self): ...

    @abstractmethod
    def __int__(self): ...

    @abstractmethod
    def __float__(self): ...

    @abstractmethod
    def __complex__(self): ...

    @abstractmethod
    def __abs__(self) -> Expr: ...

    @abstractmethod
    def __pos__(self) -> Expr: ...

    @abstractmethod
    def __neg__(self) -> Expr: ...

    @abstractmethod
    def __eq__(self, other): ...

    @abstractmethod
    def __le__(self, other): ...

    @abstractmethod
    def __lt__(self, other): ...

    @abstractmethod
    def __ge__(self, other): ...

    @abstractmethod
    def __gt__(self, other): ...

    @property
    def numerator(self) -> Expr: ...

    @property
    def denominator(self) -> Literal[1]: ...

    @property
    def types(self) -> set[type]: ...

    @property
    def integer(self) -> int: ...

    @property
    def reals(self) -> list[Real]: ...


_Expr_Operatable = Union[int, float, Rational, Real, Expr]


class Mul(Expr):

    @overload
    def __init__(self,
                 *exprs: Union[int, Real, Expr]
                ): ...

    @overload
    def __init__(self,
                 *,
                 _int: Optional[int, Expr] = ...,
                 _lazy: Optional[list[Real]] = ...
                ): ...

    @property
    def eval(self) -> Any: ...

    def equivalent(self, other: Mul) -> bool: ...

    def simplify(self, *, _update: Optional[bool] = ...) -> Mul: ...

    def __str__(self): ...
    def __repr__(self): ...

    def __add__(self, other: _Expr_Operatable) -> Mul: ...
    def __radd__(self, other: _Expr_Operatable) -> Mul: ...
    def __sub__(self, other: _Expr_Operatable) -> Mul: ...
    def __rsub__(self, other: _Expr_Operatable) -> Mul: ...
    def __mul__(self, other: _Expr_Operatable) -> Mul: ...
    def __rmul__(self, other: _Expr_Operatable) -> Mul: ...
    def __floordiv__(self, other: _Expr_Operatable) -> Mul: ...
    def __truediv__(self, other: _Expr_Operatable): ...

    def __int__(self): ...
    def __float__(self): ...
    def __complex__(self): ...
    def __abs__(self) -> Mul: ...
    def __pos__(self) -> Mul: ...
    def __neg__(self) -> Mul: ...
    def __hash__(self) -> int: ...

    def __eq__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...


class Add(Expr):

    def __init__(self,
                 *exprs: Optional[Union[int, Real]],
                 _int: Optional[int] = ...,
                 _lazy: Optional[list[Real]] = ...
                 ) -> Add: ...

    @property
    def eval(self) -> float: ...

    @property
    def reals(self) -> list[Union[Real, Mul]]: ...

    @property
    def numerator(self) -> Add: ...

    @property
    def denominator(self) -> Literal[1]: ...

    def simplify(self, *, _update: Optional[bool] = ...) -> Add: ...

    def __str__(self): ...
    def __repr__(self): ...

    def __add__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __radd__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __sub__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __rsub__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __mul__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __rmul__(self, other: Union[int, float, Rational, Sqrt, Add]) -> Union[Add, NotImplemented]: ...
    def __floordiv__(self, other: Union[int, float, Rational, Sqrt]) -> Union[Add, NotImplemented]: ...
    def __truediv__(self, other: Union[int, float, Rational, Sqrt]) -> Union[Add, NotImplemented]: ...

    def __int__(self): ...
    def __float__(self): ...
    def __complex__(self): ...
    def __iter__(self) -> iter: ...
    def __abs__(self) -> Add: ...
    def __pos__(self) -> Add: ...
    def __neg__(self) -> Add: ...

    def __eq__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
