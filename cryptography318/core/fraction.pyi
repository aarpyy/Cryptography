from typing import Type, Union, overload, Any, Optional, TypeVar, Callable
from numbers import Real, Rational, Complex
from decimal import Decimal
from fractions import Fraction as PyFraction


from .expr import Expr
from .sqrt import Sqrt

_F = TypeVar("_F")


_FComparable = Union[Rational, Complex, float]


class Fraction(Rational):

    @overload
    def __new__(
            cls: Type[_F],
            numerator: Union[int, Rational, Expr, Sqrt] = ...,
            denominator: Optional[int, Rational, Expr, Sqrt] = ...,
            *,
            _normalize: bool = ...,
    ) -> Union[_F, float]: ...

    @overload
    def __new__(
            cls: Type[_F],
            numerator: Union[float, Decimal, int, str, Expr, Sqrt] = ...,
            *,
            _normalize: bool = ...,
    ) -> _F: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    @property
    def numerator(self) -> Union[int, Expr]: ...

    @property
    def denominator(self) -> Union[int, Expr]: ...

    @property
    def reciprocal(self) -> Fraction: ...

    def _operator_fallbacks(fraction_operator: Callable, std_operator: Callable) -> tuple[Callable, Callable]: ...

    # __add__, __radd__
    @overload
    def __add__(self, other: Union[int, Fraction, PyFraction]) -> Fraction: ...
    @overload
    def __add__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __add__(self, other: complex) -> complex: ...
    @overload
    def __radd__(self, other: Rational) -> Fraction: ...
    @overload
    def __radd__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __radd__(self, other: Real) -> float: ...
    @overload
    def __radd__(self, other: Complex) -> complex: ...
    @overload
    def __radd__(self, other: Any) -> Any: ...

    #__sub__, __rsub__
    @overload
    def __sub__(self, other: Union[int, Fraction, PyFraction]) -> Fraction: ...
    @overload
    def __sub__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __sub__(self, other: complex) -> complex: ...
    @overload
    def __rsub__(self, other: Rational) -> Fraction: ...
    @overload
    def __rsub__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __rsub__(self, other: Real) -> float: ...
    @overload
    def __rsub__(self, other: Complex) -> complex: ...
    @overload
    def __rsub__(self, other: Any) -> Any: ...

    # __mul__, __rmul__
    @overload
    def __mul__(self, other: Union[int, Fraction, PyFraction, Expr]) -> Fraction: ...
    @overload
    def __mul__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __mul__(self, other: complex) -> complex: ...
    @overload
    def __rmul__(self, other: Union[Rational, Expr]) -> Fraction: ...
    @overload
    def __rmul__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __rmul__(self, other: Real) -> float: ...
    @overload
    def __rmul__(self, other: Complex) -> complex: ...
    @overload
    def __rmul__(self, other: Any) -> Any: ...

    # __floordiv__, __rfloordiv__
    @overload
    def __floordiv__(self, other: Union[int, Fraction, PyFraction, Expr]) -> Fraction: ...
    @overload
    def __floordiv__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __floordiv__(self, other: complex) -> complex: ...
    @overload
    def __rfloordiv__(self, other: Union[Rational, Expr]) -> Fraction: ...
    @overload
    def __rfloordiv__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __rfloordiv__(self, other: Real) -> float: ...
    @overload
    def __rfloordiv__(self, other: Complex) -> complex: ...
    @overload
    def __rfloordiv__(self, other: Any) -> Any: ...

    # __truediv__, __rtruediv__
    @overload
    def __truediv__(self, other: Union[int, Fraction, PyFraction, Expr]) -> Fraction: ...
    @overload
    def __truediv__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __truediv__(self, other: complex) -> complex: ...
    @overload
    def __rtruediv__(self, other: Union[Rational, Expr]) -> Fraction: ...
    @overload
    def __rtruediv__(self, other: float) -> Union[Fraction, float]: ...
    @overload
    def __rtruediv__(self, other: Real) -> float: ...
    @overload
    def __rtruediv__(self, other: Complex) -> complex: ...
    @overload
    def __rtruediv__(self, other: Any) -> Any: ...

    # __mod__, __rmod__
    @overload
    def __mod__(self, other: Union[int, Fraction, PyFraction]) -> Fraction: ...
    @overload
    def __mod__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __mod__(self, other: complex) -> complex: ...
    @overload
    def __rmod__(self, other: Rational) -> Fraction: ...
    @overload
    def __rmod__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __rmod__(self, other: Real) -> float: ...
    @overload
    def __rmod__(self, other: Complex) -> complex: ...
    @overload
    def __rmod__(self, other: Any) -> Any: ...

    # __divmod__, __rdivmod__
    @overload
    def __divmod__(self, other: Union[int, Fraction, PyFraction]) -> Fraction: ...
    @overload
    def __divmod__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __divmod__(self, other: complex) -> complex: ...
    @overload
    def __rdivmod__(self, other: Rational) -> Fraction: ...
    @overload
    def __rdivmod__(self, other: Union[Expr, float]) -> Union[Fraction, float]: ...
    @overload
    def __rdivmod__(self, other: Real) -> float: ...
    @overload
    def __rdivmod__(self, other: Complex) -> complex: ...
    @overload
    def __rdivmod__(self, other: Any) -> Any: ...

    def _pow(a, b: Union[int, Rational]) -> Union[Fraction, float]: ...

    @overload
    def __pow__(self, power: Rational, modulo: Union[Rational, None] = ...) -> Fraction: ...
    @overload
    def __pow__(self, power: Real, modulo: Union[Real, None] = ...) -> float: ...
    @overload
    def __rpow__(self, base: Rational) -> Union[Fraction, float]: ...
    @overload
    def __rpow__(self, base: Any) -> Any: ...

    def __int__(self) -> int: ...

    def __float__(self) -> float: ...

    def __complex__(self) -> complex: ...

    def __bool__(self) -> bool: ...

    def __trunc__(self) -> int: ...

    def __floor__(self) -> int: ...

    def __ceil__(self) -> int: ...

    @overload
    def __round__(self, ndigits: Union[int, None] = ...) -> Real: ...

    def __abs__(self) -> Fraction: ...

    def __pos__(self) -> Fraction: ...

    def __neg__(self) -> Fraction: ...

    def __hash__(self) -> int: ...

    def __eq__(self, other: _FComparable) -> bool: ...

    def __ne__(self, other: _FComparable) -> bool: ...

    def _compare(self, other: _FComparable, op: Callable) -> bool: ...

    def __lt__(self, other: _FComparable) -> bool: ...

    def __le__(self, other: _FComparable) -> bool: ...

    def __gt__(self, other: _FComparable) -> bool: ...

    def __ge__(self, other: _FComparable) -> bool: ...
