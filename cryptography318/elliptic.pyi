from abc import ABCMeta, abstractmethod
from typing import Union, overload, Optional
from random import Random

rand: Random

class Curve(metaclass=ABCMeta):
    modulus: int
    @abstractmethod
    def __eq__(self, other: Curve) -> bool: ...
    @overload
    @abstractmethod
    def point(self, x: int) -> 'Point': ...
    @overload
    @abstractmethod
    def point(self, x: int, param: int) -> 'Point': ...
    @abstractmethod
    def point(self, *args: int) -> 'Point': ...

class Weierstrass(Curve):
    a: int
    b: int
    def __new__(cls, a: int, b: int, mod: int) -> Weierstrass: ...
    def __eq__(self, other: Weierstrass) -> bool: ...
    def point(self, x: int) -> WeierstrassPoint: ...
    @classmethod
    def safe_curve_and_point(cls, p: int) -> tuple[Weierstrass, WeierstrassPoint]: ...

class Montgomery(Curve):
    A_24: int
    def __new__(cls, A: int, mod: int) -> Montgomery: ...
    def __eq__(self, other: Montgomery) -> bool: ...
    def point(self, *args: int) -> MontgomeryPoint: ...
    @classmethod
    def safe_curve_and_point(cls, p: int) -> Union[tuple[Montgomery, MontgomeryPoint], int]: ...
    @classmethod
    def z_1_curve_and_point(cls, p: int) -> Union[tuple[Montgomery, MontgomeryPoint], int]: ...

class Point(metaclass=ABCMeta):
    x: int
    curve: Curve
    modulus: int
    @abstractmethod
    def __eq__(self, other: Point) -> bool: ...
    @abstractmethod
    def __neg__(self) -> Point: ...
    @abstractmethod
    def __add__(self, other: Point) -> Point: ...
    @abstractmethod
    def __mul__(self, other: int) -> Point: ...
    @property
    @abstractmethod
    def points(self) -> tuple: ...

class Identity(Point):
    def __new__(cls) -> Identity: ...
    def __eq__(self, other: Point) -> bool: ...
    def __neg__(self) -> Point: ...
    def __add__(self, other: Point) -> Point: ...
    def __mul__(self, other: int) -> Point: ...
    @property
    def points(self) -> tuple[None, None]: ...

class WeierstrassPoint(Point):
    curve: Weierstrass
    y: int
    def __new__(cls, x: int, y: int, curve: Weierstrass) -> WeierstrassPoint: ...
    def __eq__(self, other: Union[WeierstrassPoint, Identity]) -> bool: ...
    def __neg__(self) -> WeierstrassPoint: ...
    def __add__(self, other: Union[WeierstrassPoint, Identity]) -> Union[WeierstrassPoint, Identity]: ...
    def __mul__(self, other: int) -> Union[WeierstrassPoint, Identity]: ...
    @property
    def points(self) -> tuple[int, int]: ...

class MontgomeryPoint(Point):
    curve: Montgomery
    z: int
    def __new__(cls, x: int, z: int, curve: Montgomery) -> MontgomeryPoint: ...
    def __eq__(self, other: MontgomeryPoint) -> bool: ...
    def __neg__(self) -> MontgomeryPoint: ...
    def add_general(self, Q: MontgomeryPoint, difference: MontgomeryPoint) -> MontgomeryPoint: ...
    def add(self, Q: MontgomeryPoint, difference: MontgomeryPoint) -> MontgomeryPoint: ...
    def add_z1(self, Q: MontgomeryPoint, difference: MontgomeryPoint) -> MontgomeryPoint: ...
    def double(self) -> MontgomeryPoint: ...
    def __add__(self, other) -> NotImplemented: ...
    def ladder(self, k: int) -> MontgomeryPoint: ...
    def ladder_z1(self, k: int) -> MontgomeryPoint: ...
    def __mul__(self, k: int) -> MontgomeryPoint: ...
    @property
    def points(self) -> tuple[int, int]: ...

def ecm_mont_basic(N: int, B1: int = ..., B2: int = ..., _retry: int = ...) -> Optional[int]: ...
def ecm_mont(N: int, B1: int = ..., B2: int = ..., _retry: int = ...) -> Optional[int]: ...
def ecm_weierstrass(N: int, B: int = ..., _retry: int = ...) -> Optional[int]: ...
def lenstra_ecm(N: int, B: int = ..., _retry: int = ...) -> Optional[int]: ...
